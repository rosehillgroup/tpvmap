import { Lab, linearRGBToSRGB, linearRGBToXYZ, xyzToLab } from './convert';
import { deltaE2000 } from './deltaE';
import { TPVColour } from './blend';
import { 
  EnhancedTPVColour, 
  enhanceTPVColours, 
  mixLinearRGB, 
  normalizeWeights,
  deduplicateRecipes,
  mmrSelect,
  DedupeRecipe
} from './smartUtils';
import { evaluateBlendPenalties } from './penalties';
import { findOptimalParts, PartsResult } from './smartParts';

export interface SmartSolverConstraints {
  maxComponents: 1 | 2 | 3;
  stepPct: number;
  minPct: number;
  mode: 'percent' | 'parts';
  parts?: {
    enabled: boolean;
    total?: number;
    minPer?: number;
  };
  preferAnchor?: boolean; // Force main component to be closest single
}

export interface SmartRecipe {
  components: Array<{ code: string; pct: number }>;
  weights: Record<string, number>; // For compatibility
  parts?: Record<string, number>;
  total?: number;
  lab: Lab;
  rgb: { R: number; G: number; B: number };
  deltaE: number;
  baseDeltaE: number; // ΔE without penalties/bonuses
  note?: string;
  reasoning?: string;
}

interface TwoWayBlend {
  i: number;
  j: number;
  p: number;
  lab: Lab;
  deltaE: number;
  adjustedDeltaE: number;
}

export class SmartBlendSolver {
  private enhancedColours: EnhancedTPVColour[];
  private twoWayCache: TwoWayBlend[] = [];
  private singleDistances: number[] = [];
  
  constructor(
    private colours: TPVColour[],
    private constraints: SmartSolverConstraints
  ) {
    this.enhancedColours = enhanceTPVColours(colours);
    this.precomputeTwoWayBlends();
  }
  
  /**
   * Get hue sector (0-5) for a Lab color in a*-b* plane
   */
  private getHueSector(lab: Lab): number {
    const angle = Math.atan2(lab.b, lab.a) * 180 / Math.PI;
    const normalizedAngle = ((angle % 360) + 360) % 360; // 0-360
    return Math.floor(normalizedAngle / 60); // 6 sectors of 60° each
  }

  /**
   * Convert SmartRecipe to DedupeRecipe format
   */
  private toDedupeRecipe(recipe: SmartRecipe): DedupeRecipe {
    return {
      components: recipe.components,
      mode: this.constraints.mode,
      parts: recipe.parts && recipe.total ? {
        codes: Object.keys(recipe.parts),
        parts: Object.values(recipe.parts),
        total: recipe.total
      } : undefined,
      lab: recipe.lab,
      deltaE: recipe.deltaE,
      weights: recipe.weights
    };
  }

  /**
   * Convert DedupeRecipe back to SmartRecipe format
   */
  private fromDedupeRecipe(dedupeRecipe: DedupeRecipe): SmartRecipe {
    const partsObj = dedupeRecipe.parts ? 
      dedupeRecipe.parts.codes.reduce((obj, code, i) => {
        obj[code] = dedupeRecipe.parts!.parts[i];
        return obj;
      }, {} as Record<string, number>) : undefined;

    // Calculate RGB from weights using the mixing system
    const rgb = this.calculateRGBFromWeights(dedupeRecipe.weights);

    return {
      components: dedupeRecipe.components,
      weights: dedupeRecipe.weights,
      parts: partsObj,
      total: dedupeRecipe.parts?.total,
      lab: dedupeRecipe.lab,
      rgb,
      deltaE: dedupeRecipe.deltaE,
      baseDeltaE: dedupeRecipe.deltaE, // Approximation
      note: dedupeRecipe.mode === 'parts' ? 'Parts blend' : 'Percentage blend',
      reasoning: 'Generated by enhanced solver'
    };
  }

  /**
   * Calculate RGB from weights using the color mixing system
   */
  private calculateRGBFromWeights(weights: Record<string, number>): { R: number; G: number; B: number } {
    const components = Object.entries(weights).map(([code, weight]) => {
      const colour = this.enhancedColours.find(c => c.code === code);
      if (!colour) {
        // Fallback for unknown colors
        return { color: { R: 0.5, G: 0.5, B: 0.5 }, weight };
      }
      return { color: colour.linearRGB, weight };
    });

    if (components.length === 0) {
      return { R: 128, G: 128, B: 128 }; // Neutral gray fallback
    }

    const mixedLinear = mixLinearRGB(components);
    return linearRGBToSRGB(mixedLinear);
  }


  /**
   * Solve for best blends matching target color with enhanced deduplication
   */
  solve(targetLab: Lab, maxResults: number = 5): SmartRecipe[] {
    const results: SmartRecipe[] = [];
    
    // Calculate distances from target to all single colors (for anchor bonus)
    this.singleDistances = this.enhancedColours.map(colour => 
      deltaE2000(targetLab, { L: colour.L, a: colour.a, b: colour.b })
    );
    
    // Phase 1: Single components
    if (this.constraints.maxComponents >= 1) {
      const singleResults = this.solveSingleComponents(targetLab);
      results.push(...singleResults);
    }
    
    // Phase 2: Two-way blends
    if (this.constraints.maxComponents >= 2) {
      const twoWayResults = this.solveTwoWayBlends(targetLab);
      results.push(...twoWayResults);
    }
    
    // Phase 3: Three-way blends (seeded from hue-diverse two-way)
    if (this.constraints.maxComponents >= 3) {
      const threeWayResults = this.solveThreeWayBlendsWithHueDiversity(targetLab);
      results.push(...threeWayResults);
    }
    
    // Auto-expansion fallback BEFORE deduplication if needed
    if (results.length < maxResults * 3 && this.constraints.maxComponents < 3) {
      const expandedResults = this.autoExpandSearch(targetLab, maxResults * 2);
      results.push(...expandedResults);
    }
    
    // Apply parts conversion BEFORE deduplication to ensure proper canonical keys
    const partsConvertedResults = results.map(recipe => this.convertToPartsIfNeeded(recipe, targetLab));
    
    // Convert to DedupeRecipe format for enhanced deduplication
    const dedupeRecipes = partsConvertedResults.map(r => this.toDedupeRecipe(r));
    
    // Apply comprehensive deduplication
    const uniqueRecipes = deduplicateRecipes(dedupeRecipes);
    
    // Apply MMR selection for diversity
    const diverseRecipes = mmrSelect(uniqueRecipes, maxResults * 2, 0.75);
    
    // Convert back to SmartRecipe format
    const finalResults = diverseRecipes.slice(0, maxResults).map(dedupeRecipe => {
      return this.fromDedupeRecipe(dedupeRecipe);
    });
    
    return finalResults;
  }

  /**
   * Auto-expand search constraints when results are limited (simplified approach)
   */
  private autoExpandSearch(targetLab: Lab, neededCount: number): SmartRecipe[] {
    const expandedResults: SmartRecipe[] = [];
    
    // Strategy 1: Generate additional 3-way blends if we were limited to 2-way
    if (this.constraints.maxComponents < 3) {
      // Temporarily allow 3-way blends for expansion
      const savedMaxComponents = this.constraints.maxComponents;
      (this.constraints as any).maxComponents = 3;
      
      const threeWayResults = this.solveThreeWayBlendsWithHueDiversity(targetLab);
      expandedResults.push(...threeWayResults.slice(0, Math.ceil(neededCount / 2)));
      
      // Restore original constraint
      (this.constraints as any).maxComponents = savedMaxComponents;
    }
    
    // Strategy 2: Generate more two-way blends with relaxed constraints
    if (expandedResults.length < neededCount) {
      // Temporarily relax minimum percentage constraint
      const savedMinPct = this.constraints.minPct;
      const relaxedMinPct = Math.max(0.05, this.constraints.minPct - 0.03);
      (this.constraints as any).minPct = relaxedMinPct;
      
      // Re-score existing two-way cache with relaxed constraints
      for (const blend of this.twoWayCache.slice(0, neededCount * 2)) {
        if (blend.p >= relaxedMinPct && (1 - blend.p) >= relaxedMinPct) {
          // Recalculate with relaxed constraints
          blend.deltaE = deltaE2000(targetLab, blend.lab);
          
          const c1 = this.enhancedColours[blend.i];
          const c2 = this.enhancedColours[blend.j];
          
          const penalty = evaluateBlendPenalties(
            [
              { lab: { L: c1.L, a: c1.a, b: c1.b }, weight: blend.p },
              { lab: { L: c2.L, a: c2.a, b: c2.b }, weight: 1 - blend.p }
            ],
            targetLab,
            this.singleDistances
          );
          
          blend.adjustedDeltaE = blend.deltaE + penalty;
          
          const dominant = blend.p >= 0.6 ? c1 : (blend.p <= 0.4 ? c2 : null);
          const reasoning = dominant 
            ? `Relaxed ${dominant.name} with ${dominant === c1 ? c2.name : c1.name} adjustment`
            : `Relaxed balanced mix of ${c1.name} and ${c2.name}`;
          
          expandedResults.push({
            components: [
              { code: c1.code, pct: blend.p },
              { code: c2.code, pct: 1 - blend.p }
            ],
            weights: { [c1.code]: blend.p, [c2.code]: 1 - blend.p },
            lab: blend.lab,
            rgb: linearRGBToSRGB(mixLinearRGB([
              { color: c1.linearRGB, weight: blend.p },
              { color: c2.linearRGB, weight: 1 - blend.p }
            ])),
            deltaE: blend.adjustedDeltaE,
            baseDeltaE: blend.deltaE,
            note: '2-component expanded blend',
            reasoning
          });
          
          if (expandedResults.length >= neededCount) break;
        }
      }
      
      // Restore original constraint
      (this.constraints as any).minPct = savedMinPct;
    }
    
    return expandedResults.slice(0, neededCount);
  }
  
  /**
   * Precompute all 2-way blends with multi-step strategy
   */
  private precomputeTwoWayBlends(): void {
    const { minPct } = this.constraints;
    const maxPct = 1 - minPct;
    
    // Use coarse step for initial exploration
    const coarseStep = Math.max(0.04, this.constraints.stepPct * 2);
    
    for (let i = 0; i < this.enhancedColours.length; i++) {
      for (let j = i + 1; j < this.enhancedColours.length; j++) {
        const c1 = this.enhancedColours[i];
        const c2 = this.enhancedColours[j];
        
        // Coarse exploration
        for (let p = minPct; p <= maxPct; p += coarseStep) {
          const mixedLinear = mixLinearRGB([
            { color: c1.linearRGB, weight: p },
            { color: c2.linearRGB, weight: 1 - p }
          ]);
          
          const mixedXYZ = linearRGBToXYZ(mixedLinear);
          const lab = xyzToLab(mixedXYZ);
          
          this.twoWayCache.push({
            i, j, p,
            lab,
            deltaE: 0, // Will be calculated per target
            adjustedDeltaE: 0
          });
        }
      }
    }
  }
  
  /**
   * Refine top candidates with fine step size
   */
  private refineTopCandidates(candidates: TwoWayBlend[], targetLab: Lab, count: number = 20): TwoWayBlend[] {
    const refined: TwoWayBlend[] = [];
    const fineStep = Math.min(0.01, this.constraints.stepPct);
    
    for (const candidate of candidates.slice(0, count)) {
      const c1 = this.enhancedColours[candidate.i];
      const c2 = this.enhancedColours[candidate.j];
      
      // Refine around the coarse candidate
      const searchRange = 0.08; // ±4% around coarse result
      const minP = Math.max(this.constraints.minPct, candidate.p - searchRange);
      const maxP = Math.min(1 - this.constraints.minPct, candidate.p + searchRange);
      
      let bestRefined = candidate;
      
      for (let p = minP; p <= maxP; p += fineStep) {
        const mixedLinear = mixLinearRGB([
          { color: c1.linearRGB, weight: p },
          { color: c2.linearRGB, weight: 1 - p }
        ]);
        
        const mixedXYZ = linearRGBToXYZ(mixedLinear);
        const lab = xyzToLab(mixedXYZ);
        const deltaE = deltaE2000(targetLab, lab);
        
        // Apply penalties
        const penalty = evaluateBlendPenalties(
          [
            { lab: { L: c1.L, a: c1.a, b: c1.b }, weight: p },
            { lab: { L: c2.L, a: c2.a, b: c2.b }, weight: 1 - p }
          ],
          targetLab,
          this.singleDistances
        );
        
        const adjustedDeltaE = deltaE + penalty;
        
        if (adjustedDeltaE < bestRefined.adjustedDeltaE) {
          bestRefined = {
            i: candidate.i,
            j: candidate.j,
            p,
            lab,
            deltaE,
            adjustedDeltaE
          };
        }
      }
      
      refined.push(bestRefined);
    }
    
    return refined.sort((a, b) => a.adjustedDeltaE - b.adjustedDeltaE);
  }
  
  /**
   * Find best single component matches
   */
  private solveSingleComponents(targetLab: Lab): SmartRecipe[] {
    const results: SmartRecipe[] = [];
    
    for (let i = 0; i < this.enhancedColours.length; i++) {
      const colour = this.enhancedColours[i];
      const colourLab = { L: colour.L, a: colour.a, b: colour.b };
      const deltaE = deltaE2000(targetLab, colourLab);
      
      results.push({
        components: [{ code: colour.code, pct: 1 }],
        weights: { [colour.code]: 1 },
        lab: colourLab,
        rgb: { R: colour.R, G: colour.G, B: colour.B },
        deltaE,
        baseDeltaE: deltaE,
        note: 'Single component',
        reasoning: `Direct match with ${colour.name}`
      });
    }
    
    return results.sort((a, b) => a.deltaE - b.deltaE).slice(0, 2);
  }
  
  /**
   * Find best two-way blends with smart penalties and refinement
   */
  private solveTwoWayBlends(targetLab: Lab): SmartRecipe[] {
    // Score all cached blends for this target
    for (const blend of this.twoWayCache) {
      blend.deltaE = deltaE2000(targetLab, blend.lab);
      
      // Apply smart penalties
      const c1 = this.enhancedColours[blend.i];
      const c2 = this.enhancedColours[blend.j];
      
      const penalty = evaluateBlendPenalties(
        [
          { lab: { L: c1.L, a: c1.a, b: c1.b }, weight: blend.p },
          { lab: { L: c2.L, a: c2.a, b: c2.b }, weight: 1 - blend.p }
        ],
        targetLab,
        this.singleDistances
      );
      
      blend.adjustedDeltaE = blend.deltaE + penalty;
    }
    
    // Get top coarse candidates
    const coarseCandidates = this.twoWayCache
      .slice() // Don't modify original
      .sort((a, b) => a.adjustedDeltaE - b.adjustedDeltaE)
      .slice(0, 30);
    
    // Refine with fine step size
    const refined = this.refineTopCandidates(coarseCandidates, targetLab, 15);
    
    return refined.slice(0, 10).map(blend => {
      const c1 = this.enhancedColours[blend.i];
      const c2 = this.enhancedColours[blend.j];
      
      // Create intuitive reasoning
      const dominant = blend.p >= 0.6 ? c1 : (blend.p <= 0.4 ? c2 : null);
      const reasoning = dominant 
        ? `Anchor ${dominant.name} with ${dominant === c1 ? c2.name : c1.name} adjustment`
        : `Balanced mix of ${c1.name} and ${c2.name}`;
      
      return {
        components: [
          { code: c1.code, pct: blend.p },
          { code: c2.code, pct: 1 - blend.p }
        ],
        weights: { [c1.code]: blend.p, [c2.code]: 1 - blend.p },
        lab: blend.lab,
        rgb: linearRGBToSRGB(mixLinearRGB([
          { color: c1.linearRGB, weight: blend.p },
          { color: c2.linearRGB, weight: 1 - blend.p }
        ])),
        deltaE: blend.adjustedDeltaE,
        baseDeltaE: blend.deltaE,
        note: '2-component blend',
        reasoning
      };
    });
  }
  
  /**
   * Find best three-way blends with hue-diverse seeding
   */
  private solveThreeWayBlendsWithHueDiversity(targetLab: Lab): SmartRecipe[] {
    const results: SmartRecipe[] = [];
    
    // Group 2-way blends by hue sector
    const sectorBlends = new Map<number, TwoWayBlend[]>();
    
    for (const blend of this.twoWayCache) {
      blend.deltaE = deltaE2000(targetLab, blend.lab);
      
      // Apply smart penalties
      const c1 = this.enhancedColours[blend.i];
      const c2 = this.enhancedColours[blend.j];
      
      const penalty = evaluateBlendPenalties(
        [
          { lab: { L: c1.L, a: c1.a, b: c1.b }, weight: blend.p },
          { lab: { L: c2.L, a: c2.a, b: c2.b }, weight: 1 - blend.p }
        ],
        targetLab,
        this.singleDistances
      );
      
      blend.adjustedDeltaE = blend.deltaE + penalty;
      
      // Assign to hue sector
      const sector = this.getHueSector(blend.lab);
      const sectorList = sectorBlends.get(sector) || [];
      sectorList.push(blend);
      sectorBlends.set(sector, sectorList);
    }
    
    // Get best 4 candidates per sector for diversity
    const seedBlends: TwoWayBlend[] = [];
    for (const sectorList of Array.from(sectorBlends.values())) {
      sectorList.sort((a, b) => a.adjustedDeltaE - b.adjustedDeltaE);
      seedBlends.push(...sectorList.slice(0, 4)); // Top 4 per sector
    }
    
    // If we don't have enough diverse seeds, add global top candidates
    if (seedBlends.length < 24) {
      const allBlends = Array.from(sectorBlends.values()).flat();
      allBlends.sort((a, b) => a.adjustedDeltaE - b.adjustedDeltaE);
      const needed = 30 - seedBlends.length;
      seedBlends.push(...allBlends.slice(0, needed));
    }
    
    return this.generateThreeWayFromSeeds(seedBlends, targetLab);
  }

  /**
   * Generate three-way blends from seed two-way blends
   */
  private generateThreeWayFromSeeds(seeds: TwoWayBlend[], targetLab: Lab): SmartRecipe[] {
    const results: SmartRecipe[] = [];
    
    for (const seed of seeds) {
      const usedIndices = [seed.i, seed.j];
      
      // Try adding each unused color
      for (let k = 0; k < this.enhancedColours.length; k++) {
        if (usedIndices.includes(k)) continue;
        
        const c3 = this.enhancedColours[k];
        
        // Try different amounts of the third component
        for (let p3 = this.constraints.minPct; 
             p3 <= 1 - 2 * this.constraints.minPct; 
             p3 += this.constraints.stepPct * 2) { // Coarser step for 3-way
          
          const remainingWeight = 1 - p3;
          const p1 = Math.max(this.constraints.minPct, seed.p * remainingWeight);
          const p2 = remainingWeight - p1;
          
          if (p2 < this.constraints.minPct) continue;
          
          // Normalize weights
          const weights = normalizeWeights([p1, p2, p3]);
          const [w1, w2, w3] = weights;
          
          const mixedLinear = mixLinearRGB([
            { color: this.enhancedColours[seed.i].linearRGB, weight: w1 },
            { color: this.enhancedColours[seed.j].linearRGB, weight: w2 },
            { color: c3.linearRGB, weight: w3 }
          ]);
          
          const mixedXYZ = linearRGBToXYZ(mixedLinear);
          const lab = xyzToLab(mixedXYZ);
          const baseDeltaE = deltaE2000(targetLab, lab);
          
          // Apply penalties
          const penalty = evaluateBlendPenalties(
            [
              { lab: { L: this.enhancedColours[seed.i].L, a: this.enhancedColours[seed.i].a, b: this.enhancedColours[seed.i].b }, weight: w1 },
              { lab: { L: this.enhancedColours[seed.j].L, a: this.enhancedColours[seed.j].a, b: this.enhancedColours[seed.j].b }, weight: w2 },
              { lab: { L: c3.L, a: c3.a, b: c3.b }, weight: w3 }
            ],
            targetLab,
            this.singleDistances
          );
          
          const adjustedDeltaE = baseDeltaE + penalty;
          
          results.push({
            components: [
              { code: this.enhancedColours[seed.i].code, pct: w1 },
              { code: this.enhancedColours[seed.j].code, pct: w2 },
              { code: c3.code, pct: w3 }
            ],
            weights: {
              [this.enhancedColours[seed.i].code]: w1,
              [this.enhancedColours[seed.j].code]: w2,
              [c3.code]: w3
            },
            lab,
            rgb: linearRGBToSRGB(mixedLinear),
            deltaE: adjustedDeltaE,
            baseDeltaE,
            note: '3-component blend',
            reasoning: 'Refined blend with three components'
          });
        }
      }
    }
    
    return results.sort((a, b) => a.deltaE - b.deltaE).slice(0, 5);
  }
  
  /**
   * Convert recipe to parts format if requested
   */
  private convertToPartsIfNeeded(recipe: SmartRecipe, targetLab: Lab): SmartRecipe {
    if (this.constraints.mode !== 'parts' || !this.constraints.parts?.enabled) {
      return recipe;
    }
    
    const partsResult = findOptimalParts(
      recipe.weights,
      this.enhancedColours,
      targetLab,
      {
        totals: this.constraints.parts.total ? [this.constraints.parts.total] : [9, 12, 15],
        minPer: this.constraints.parts.minPer || 1,
        maxDeltaEPenalty: 0.8
      }
    );
    
    if (partsResult) {
      return {
        ...recipe,
        parts: partsResult.parts,
        total: partsResult.total,
        weights: partsResult.weights, // Updated normalized weights
        lab: partsResult.lab,
        rgb: partsResult.rgb,
        deltaE: partsResult.deltaE,
        note: recipe.note + ` (${partsResult.total} parts total)`,
        reasoning: recipe.reasoning + ` - Snapped to ${partsResult.total} parts with ΔE ${(partsResult.deltaE - recipe.baseDeltaE).toFixed(2)} penalty`
      };
    }
    
    return recipe;
  }
}